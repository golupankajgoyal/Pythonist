from collections import deque,defaultdict

# Given a set with distinct elements, find all of its distinct subsets.
def generate_subset(arr):
    subset=[[]]
    n=len(arr)
    for i in range(n):
        size=len(subset)
        for j in range(size):
            set=list(subset[j])
            set.append(arr[i])
            subset.append(set)
    print(subset)

# arr=[1,2,3,4]
# generate_subset(arr)

#Given a set of numbers that might contain duplicates, find all of its distinct subsets.
def find_subset(arr):
    arr=sorted(arr)
    subset=[[]]
    n=len(arr)
    start=0
    endpoint=0
    for i in range(n):
        start=0
        if arr[i]==arr[i-1]:
            start=endpoint
        endpoint=len(subset)
        for j in range(start,endpoint):
            set=list(subset[j])
            set.append(arr[i])
            subset.append(set)
    print(subset)
# arr=[1,5,3,3]
# find_subset(arr)

#Given a set of distinct numbers, find all of its permutations.
def generate_permutations(arr):
    result=[]
    subset=deque()
    subset.append([])
    n=len(arr)
    for num in arr:
        subset_size=len(subset)
        for j in range(subset_size):
            word=subset.popleft()
            word_size=len(word)
            for k in range(word_size+1):
                new_word=list(word)
                new_word.insert(k,num)

                if len(new_word)==n:
                    result.append(new_word)
                else:
                    subset.append(new_word)
    print(result)
# arr=[1,2,3]
# generate_permutations(arr)

# Given a string array, find all of its permutations preserving the character sequence but changing case.

def alpha_permutation(arr):
    output=[]
    output.append(arr)
    n=len(arr)
    for i in range(n):
        size=len(output)
        char=str(arr[i])
        if char.isalpha():
            for j in range(size):
                new_word=list(output[j])
                new_word[i]=new_word[i].swapcase()
                output.append(new_word)
    print(output)

# arr=[1,"a","n","t"]
# alpha_permutation(arr)

# For a given number ‘N’, write a function to generate all combination of ‘N’ pairs of balanced parentheses.
class Parenthesis:
    def __init__(self,str,open_count,close_count):
        self.str=str
        self.open_count=open_count
        self.close_count=close_count

def balance_parentheses(n):
    result=[]
    queue=deque()
    queue.append(Parenthesis("",0,0))
    while queue:
        pattern=queue.popleft()
        if pattern.open_count==pattern.close_count==n:
            result.append(pattern.str)
        else:
            if pattern.open_count<n:
                queue.append(Parenthesis(pattern.str+"(",pattern.open_count+1,pattern.close_count))
            if pattern.open_count>pattern.close_count:
                queue.append(Parenthesis(pattern.str+")",pattern.open_count,pattern.close_count+1))
    print(result)
# balance_parentheses(4)

#Given a word, write a function to generate all of its unique generalized abbreviations.

# Generalized abbreviation of a word can be generated by replacing
# each substring of the word by the count of characters in the substring.
# Take the example of “ab” which has four substrings: “”, “a”, “b”, and “ab”.
# After replacing these substrings in the actual word by the count of characters
# we get all the generalized abbreviations: “ab”, “1b”, “a1”, and “2”.
class Abbreviate:
    def __init__(self,str,count):
        self.str=str
        self.count=count

def generalize_pattern(word):
    size=len(word)
    result=[]
    queue=deque()
    queue.append(Abbreviate("",0))
    for i in range(size+1):
        queue_size=len(queue)
        j=0
        while j<queue_size:
            curr_word=queue.popleft()
            if i==size:
                new_word=curr_word.str
                if curr_word.count==0:
                    result.append(new_word)
                else:
                    result.append(new_word+str(curr_word.count))
            else:
                queue.append(Abbreviate(curr_word.str,curr_word.count+1))
                new_word=curr_word.str
                if curr_word.count!=0:
                    new_word+=str(curr_word.count)
                queue.append(Abbreviate(new_word+word[i],0))
            j+=1
    print(result)
# word="NIKE"
# generalize_pattern(word)

# Given an expression containing digits and operations (+, -, *),
# find all possible ways in which the expression can be evaluated by grouping the numbers and operators using parentheses.

def all_ans_for_exp(exp,index,map):
    result=[]
    if index in map:
        return map[index]
    if index[0]==index[1]:
        result.append(int(exp[index[0]]))
        map[index]=result
        return map[index]
    start=index[0]
    end=index[1]
    for i in range(start,end+1):
        if not exp[i].isdigit():
            left_result=all_ans_for_exp(exp,(start,i-1),map)
            right_result=all_ans_for_exp(exp,(i+1,end),map)
            for left in left_result:
                for right in right_result:
                    if exp[i]=='+':
                        result.append(left+right)
                    elif exp[i]=='*':
                        result.append(left*right)
                    elif exp[i]=='-':
                        result.append(left-right)
    map[index]=result
    return result

def all_ans_for_exp_init(exp):
    map=defaultdict()
    output=all_ans_for_exp(exp,(0,len(exp)-1),map)
    # print(map)
    return output

# exp="2*3-4-5"
# print(all_ans_for_exp_init(exp))

# Given a number ‘n’, write a function to return all structurally unique Binary Search Trees (BST) that can store values 1 to ‘n’?
class Node:
    def __init__(self,value):
        self.value=value
        self.left=None
        self.right=None
def print_bst(node):
    if node==None:
        return
    print(node.value,end=" ")
    print_bst(node.left)
    print_bst(node.right)


def generate_unique_bst(index,map):
    if index in map:
        return map[index]
    if index[0]>index[1]:
        map[index]=[None]
        return map[index]
    result=[]
    for i in range(index[0],index[1]+1):
        left_subtree=generate_unique_bst((index[0],i-1),map)
        right_subtree=generate_unique_bst((i+1,index[1]),map)
        for left in left_subtree:
            for right in right_subtree:
                root=Node(i)
                root.left=left
                root.right=right
                result.append(root)
    map[index]=result
    return result

def generate_unique_bst_init(num):
    map=defaultdict()
    output=generate_unique_bst((1,num),map)
    for root in output:
        print_bst(root)
        print()
    print(len(output))

# generate_unique_bst_init(4)



